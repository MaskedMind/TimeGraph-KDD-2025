# -*- coding: utf-8 -*-
"""Untitled56.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FmC_F4uHztMFFNosOqbYQDWiHoGl_FCO
"""

!pip install tigramite

import numpy as np
import pandas as pd
from tigramite import plotting as tp
import matplotlib.pyplot as plt
from pathlib import Path
from scipy import stats

def get_nonlinear_equations(n_vars, max_lag):
    """Get nonlinear equations following A1's exact causal structure including lags"""
    if n_vars == 4:
        if max_lag == 2:
            return [
                # Following A1's structure exactly with nonlinear functions and same lags
                "X4[t] = 0.25 * cos(X1[t-2] * pi/2) + trend4[t] + season4[t] + e4",
                "X3[t] = 0.35 * (X4[t])^2 + trend3[t] + season3[t] + e3",  # contemporaneous
                "X2[t] = 0.3 * sin(X3[t-1] * pi/2) + trend2[t] + season2[t] + e2",  # lag-1
                "X1[t] = 0.4 * (X2[t])^3 + trend1[t] + season1[t] + e1"  # contemporaneous
            ]
        elif max_lag == 3:
            return [
                "X4[t] = 0.25 * cos(X1[t-2] * pi/2) + trend4[t] + season4[t] + e4",
                "X3[t] = 0.35 * (X4[t])^2 + 0.2 * cos(X2[t-3] * pi/2) + trend3[t] + season3[t] + e3",
                "X2[t] = 0.3 * sin(X3[t-1] * pi/2) + trend2[t] + season2[t] + e2",
                "X1[t] = 0.4 * (X2[t])^3 + trend1[t] + season1[t] + e1"
            ]
        elif max_lag == 4:
            return [
                "X4[t] = 0.25 * cos(X1[t-4] * pi/2) + trend4[t] + season4[t] + e4",
                "X3[t] = 0.35 * (X4[t])^2 + 0.2 * cos(X2[t-3] * pi/2) + trend3[t] + season3[t] + e3",
                "X2[t] = 0.3 * sin(X3[t-1] * pi/2) + trend2[t] + season2[t] + e2",
                "X1[t] = 0.4 * (X2[t])^3 + trend1[t] + season1[t] + e1"
            ]
    elif n_vars == 6:
        if max_lag == 2:
            return [
                # Following A1's structure for 6 variables with exact lags
                "X6[t] = 0.85 * sin(X5[t] * pi/2) + trend6[t] + season6[t] + e6",  # contemporaneous
                "X5[t] = 0.4 * cos(X4[t-1] * pi/2) + trend5[t] + season5[t] + e5",  # lag-1
                "X4[t] = 0.25 * cos(X1[t-2] * pi/2) + 0.3 * sin(X5[t-1] * pi/2) + trend4[t] + season4[t] + e4",  # lag-2, lag-1
                "X3[t] = 0.35 * (X4[t])^2 + trend3[t] + season3[t] + e3",  # contemporaneous
                "X2[t] = 0.3 * sin(X3[t-1] * pi/2) + trend2[t] + season2[t] + e2",  # lag-1
                "X1[t] = 0.4 * (X2[t])^3 + trend1[t] + season1[t] + e1"  # contemporaneous
            ]
        elif max_lag == 3:
            return [
                "X6[t] = 0.85 * sin(X5[t] * pi/2) + trend6[t] + season6[t] + e6",
                "X5[t] = 0.4 * cos(X4[t-1] * pi/2) + trend5[t] + season5[t] + e5",
                "X4[t] = 0.25 * cos(X1[t-2] * pi/2) + trend4[t] + season4[t] + e4",  # Removed X5[t-1] term
                "X3[t] = 0.35 * (X4[t])^2 + 0.2 * cos(X2[t-3] * pi/2) + trend3[t] + season3[t] + e3",  # Additional lag-3 term
                "X2[t] = 0.3 * sin(X3[t-1] * pi/2) + trend2[t] + season2[t] + e2",
                "X1[t] = 0.4 * (X2[t])^3 + trend1[t] + season1[t] + e1"
            ]
        elif max_lag == 4:
            return [
                "X6[t] = 0.85 * sin(X5[t] * pi/2) + trend6[t] + season6[t] + e6",
                "X5[t] = 0.4 * cos(X4[t-1] * pi/2) + trend5[t] + season5[t] + e5",
                "X4[t] = 0.25 * cos(X1[t-4] * pi/2) + trend4[t] + season4[t] + e4",  # Changed to lag-4, removed X5[t-1] term
                "X3[t] = 0.35 * (X4[t])^2 + 0.2 * cos(X2[t-3] * pi/2) + trend3[t] + season3[t] + e3",
                "X2[t] = 0.3 * sin(X3[t-1] * pi/2) + trend2[t] + season2[t] + e2",
                "X1[t] = 0.4 * (X2[t])^3 + trend1[t] + season1[t] + e1"
            ]
    elif n_vars == 8:
        if max_lag == 2:
            return [
                # Following A1's structure for 8 variables with exact lags
                "X8[t] = 0.4 * sin(X7[t] * pi/2) + trend8[t] + season8[t] + e8",
                "X7[t] = 0.35 * cos(X6[t-1] * pi/2) + trend7[t] + season7[t] + e7",
                "X6[t] = 0.45 * sin(X5[t] * pi/2) + trend6[t] + season6[t] + e6",
                "X5[t] = 0.4 * cos(X4[t-1] * pi/2) + trend5[t] + season5[t] + e5",
                "X4[t] = 0.25 * cos(X1[t-2] * pi/2) + 0.3 * sin(X5[t-1] * pi/2) + trend4[t] + season4[t] + e4",
                "X3[t] = 0.35 * (X4[t])^2 + trend3[t] + season3[t] + e3",
                "X2[t] = 0.3 * sin(X3[t-1] * pi/2) + trend2[t] + season2[t] + e2",
                "X1[t] = 0.4 * (X2[t])^3 + trend1[t] + season1[t] + e1"
            ]
        elif max_lag == 3:
            return [
                "X8[t] = 0.4 * sin(X7[t] * pi/2) + trend8[t] + season8[t] + e8",
                "X7[t] = 0.35 * cos(X6[t-1] * pi/2) + trend7[t] + season7[t] + e7",
                "X6[t] = 0.45 * sin(X5[t] * pi/2) + trend6[t] + season6[t] + e6",
                "X5[t] = 0.4 * cos(X4[t-1] * pi/2) + trend5[t] + season5[t] + e5",
                "X4[t] = 0.25 * cos(X1[t-2] * pi/2) + trend4[t] + season4[t] + e4",
                "X3[t] = 0.35 * (X4[t])^2 + 0.2 * cos(X2[t-3] * pi/2) + trend3[t] + season3[t] + e3",
                "X2[t] = 0.3 * sin(X3[t-1] * pi/2) + trend2[t] + season2[t] + e2",
                "X1[t] = 0.4 * (X2[t])^3 + trend1[t] + season1[t] + e1"
            ]
        elif max_lag == 4:
            return [
                "X8[t] = 0.4 * sin(X7[t] * pi/2) + trend8[t] + season8[t] + e8",
                "X7[t] = 0.35 * cos(X6[t-1] * pi/2) + trend7[t] + season7[t] + e7",
                "X6[t] = 0.45 * sin(X5[t] * pi/2) + trend6[t] + season6[t] + e6",
                "X5[t] = 0.4 * cos(X4[t-1] * pi/2) + trend5[t] + season5[t] + e5",
                "X4[t] = 0.25 * cos(X1[t-4] * pi/2) + trend4[t] + season4[t] + e4",
                "X3[t] = 0.35 * (X4[t])^2 + 0.2 * cos(X2[t-3] * pi/2) + trend3[t] + season3[t] + e3",
                "X2[t] = 0.3 * sin(X3[t-1] * pi/2) + trend2[t] + season2[t] + e2",
                "X1[t] = 0.4 * (X2[t])^3 + trend1[t] + season1[t] + e1"
            ]

    return []

class NonlinearTimeSeriesGenerator:
    def __init__(self, noise_scale=0.1, trend_strength=0.01, seasonal_strength=0.5,
                 seasonal_period=12, random_state=None):
        self.noise_scale = noise_scale
        self.trend_strength = trend_strength
        self.seasonal_strength = seasonal_strength
        self.seasonal_period = seasonal_period
        self.random_state = random_state
        if random_state is not None:
            np.random.seed(random_state)

    def generate_noise(self, size):
        """Generate Gaussian noise"""
        return np.random.normal(0, self.noise_scale, size=size)

    def generate_trend(self, n_points, var_idx):
        """Generate deterministic trend component"""
        trend_modifier = (var_idx + 1) * 0.5
        t = np.arange(n_points)
        return self.trend_strength * trend_modifier * t

    def generate_seasonality(self, n_points, var_idx):
        """Generate seasonal component using sine and cosine terms"""
        phase_shift = 2 * np.pi * var_idx / 8
        t = np.arange(n_points)

        # Combine multiple seasonal frequencies
        season1 = np.sin(2 * np.pi * t / self.seasonal_period + phase_shift)
        season2 = 0.5 * np.cos(4 * np.pi * t / self.seasonal_period + phase_shift)

        return self.seasonal_strength * (season1 + season2)

    def evaluate_term(self, term, var_values, X, t):
        """Evaluate a single term in the equation"""
        parts = term.split('*')
        coef = float(parts[0].strip())
        expr = parts[1].strip()

        # Handle autocorrelation terms
        if '[t-' in expr and not any(func in expr for func in ['cos', 'sin', '^']):
            var_idx = int(expr[1]) - 1  # Extract number after 'X'
            lag = int(expr.split('-')[1].split(']')[0])
            return coef * X[t-lag, var_idx] if t > lag else 0

        # Handle nonlinear terms
        if 'cos(' in expr:
            inner = expr.split('cos(')[1].split(')')[0]
            var_idx = int(inner.split('X')[1].split('[')[0]) - 1
            time_part = inner.split('[')[1].split(']')[0]
        elif 'sin(' in expr:
            inner = expr.split('sin(')[1].split(')')[0]
            var_idx = int(inner.split('X')[1].split('[')[0]) - 1
            time_part = inner.split('[')[1].split(']')[0]
        elif '^' in expr:
            power = int(expr.split('^')[1])
            var_idx = int(expr.split('X')[1].split('[')[0]) - 1
            time_part = expr.split('[')[1].split(']')[0]
        else:
            var_idx = int(expr.split('X')[1].split('[')[0]) - 1
            time_part = expr.split('[')[1].split(']')[0]

        # Get the value based on time index
        if time_part == 't':
            var_name = f'X{var_idx + 1}'
            value = var_values.get(var_name, X[t, var_idx])
        else:
            lag = int(time_part.split('-')[1])
            value = X[t-lag, var_idx] if t >= lag else 0

        # Apply the appropriate transformation
        if 'cos(' in expr:
            return coef * np.cos(value * np.pi/2)
        elif 'sin(' in expr:
            return coef * np.sin(value * np.pi/2)
        elif '^' in expr:
            return coef * (value ** power)
        return coef * value

    def generate_equations(self, t, X, trends, seasonality, n_vars, max_lag):
        """Execute nonlinear equations with trends and seasonality"""
        noise = self.generate_noise(n_vars)
        equations = get_nonlinear_equations(n_vars, max_lag)
        var_values = {}

        # Process each equation
        for eq in equations:
            if '=' not in eq:
                continue

            left, right = eq.split('=')
            var_name = left.split('[')[0]
            var_idx = int(var_name[1:]) - 1

            terms = right.split('+')
            value = 0

            for term in terms:
                term = term.strip()
                if term.startswith('e'):  # Noise term
                    value += noise[var_idx]
                elif term.startswith('trend'):
                    value += trends[var_idx][t]
                elif term.startswith('season'):
                    value += seasonality[var_idx][t]
                else:
                    value += self.evaluate_term(term, var_values, X, t)

            X[t, var_idx] = value
            var_values[var_name] = value

    def generate_multivariate_ts(self, n_points, n_vars, max_lag):
        """Generate multivariate time series with trends and seasonality"""
        X = np.zeros((n_points, n_vars))

        # Generate trends and seasonality for each variable
        trends = [self.generate_trend(n_points, i) for i in range(n_vars)]
        seasonality = [self.generate_seasonality(n_points, i) for i in range(n_vars)]

        # Initialize first steps with noise
        for i in range(max_lag):
            X[i] = self.generate_noise(n_vars)
            # Add trend and seasonality to initial values
            for j in range(n_vars):
                X[i, j] += trends[j][i] + seasonality[j][i]

        # Generate time series
        for t in range(max_lag, n_points):
            self.generate_equations(t, X, trends, seasonality, n_vars, max_lag)

        # Create DataFrame
        timestamps = np.arange(n_points)
        columns = [f'X{i+1}' for i in range(n_vars)]
        df = pd.DataFrame(X, columns=columns)
        df['time'] = timestamps

        return df

def extract_causal_links(equations):
    """Extract causal links from nonlinear equations"""
    links = {}

    for eq in equations:
        if '=' not in eq:
            continue

        left, right = eq.split('=')
        target = int(left.split('X')[1].split('[')[0])

        terms = right.split('+')
        for term in terms:
            term = term.strip()
            if 'X' not in term:
                continue

            # Get coefficient
            coef = float(term.split('*')[0].strip())

            # Extract source variable
            if 'cos(' in term:
                source = int(term.split('X')[1].split('[')[0])
                func = 'cos'
            elif 'sin(' in term:
                source = int(term.split('X')[1].split('[')[0])
                func = 'sin'
            elif '^' in term:
                source = int(term.split('X')[1].split('[')[0])
                func = f'power{term.split("^")[1].strip()}'
            else:
                source = int(term.split('X')[1].split('[')[0])
                func = 'linear'

            # Extract lag
            if '[t-' in term:
                lag = int(term.split('-')[1].split(']')[0])
            else:
                lag = 0

            links[(source, lag, target, func)] = coef

    return links

def save_dataset_and_graph(df, n_vars, max_lag, sample_size, output_dir="output_nonlinear"):
    """Save dataset and create visualizations"""
    Path(output_dir).mkdir(parents=True, exist_ok=True)
    base_filename = f'{output_dir}/nonlinear_ts_n{sample_size}_vars{n_vars}_lag{max_lag}'

    # Save dataset
    df.to_csv(f'{base_filename}.csv', index=False)

    # Get equations and extract links
    equations = get_nonlinear_equations(n_vars, max_lag)
    true_links = extract_causal_links(equations)

    # Create matrices for tigramite plotting
    var_names = [f'X{i+1}' for i in range(n_vars)]
    val_matrix = np.zeros((n_vars, n_vars, max_lag + 1))
    graph_matrix = np.zeros((n_vars, n_vars, max_lag + 1), dtype='bool')

    # Fill matrices based on true links
    for (source, lag, target, func), weight in true_links.items():
        source_idx = source - 1
        target_idx = target - 1
        lag_idx = lag

        # Add the link
        if lag == 0:
            # For contemporaneous links, make val_matrix symmetric
            val_matrix[source_idx, target_idx, lag_idx] = weight
            val_matrix[target_idx, source_idx, lag_idx] = weight
            # But keep graph_matrix asymmetric to show causation
            graph_matrix[source_idx, target_idx, lag_idx] = True
        else:
            # For time-lagged links
            val_matrix[source_idx, target_idx, lag_idx] = weight
            graph_matrix[source_idx, target_idx, lag_idx] = True

    # Plot and save causal graph
    plt.figure(figsize=(12, 12))
    tp.plot_time_series_graph(
        val_matrix=val_matrix,
        graph=graph_matrix,
        var_names=var_names,
        link_colorbar_label='Nonlinear Effect Strength',
        node_size=0.05
    )
    plt.title(f'Nonlinear Causal Graph\n(n={sample_size}, vars={n_vars}, lag={max_lag})')
    plt.savefig(f'{base_filename}_graph.png')
    plt.close()

    # Plot and save causal graph
    plt.figure(figsize=(12, 12))
    tp.plot_time_series_graph(
        val_matrix=val_matrix,
        graph=graph_matrix,
        var_names=var_names,
        link_colorbar_label='Nonlinear Effect Strength',
        node_size=0.05
    )
    plt.title(f'Nonlinear Causal Graph\n(n={sample_size}, vars={n_vars}, lag={max_lag})')
    plt.savefig(f'{base_filename}_graph.png')
    plt.close()

    # Plot and save causal graph
    plt.figure(figsize=(12, 12))
    tp.plot_time_series_graph(
        val_matrix=val_matrix,
        graph=graph_matrix,
        var_names=var_names,
        link_colorbar_label='Nonlinear Effect Strength',
        node_size=0.05
    )
    plt.title(f'Nonlinear Causal Graph\n(n={sample_size}, vars={n_vars}, lag={max_lag})')
    plt.savefig(f'{base_filename}_graph.png')
    plt.close()

    # Plot and save causal graph
    plt.figure(figsize=(12, 12))
    tp.plot_time_series_graph(
        val_matrix=val_matrix,
        graph=graph_matrix,
        var_names=var_names,
        link_colorbar_label='Nonlinear Effect Strength',
        node_size=0.05
    )
    plt.title(f'Nonlinear Causal Graph\n(n={sample_size}, vars={n_vars}, lag={max_lag})')
    plt.savefig(f'{base_filename}_graph.png')
    plt.close()

    # Plot time series
    plt.figure(figsize=(15, 10))
    for col in df.columns[:-1]:  # Exclude time column
        plt.plot(df['time'], df[col], label=col, alpha=0.7)
    plt.title(f'Nonlinear Time Series with Trends and Seasonality\n(n={sample_size}, vars={n_vars}, lag={max_lag})')
    plt.xlabel('Time')
    plt.ylabel('Value')
    plt.legend()
    plt.grid(True)
    plt.savefig(f'{base_filename}_series.png')
    plt.close()

    # Plot decomposition for each variable
    plt.figure(figsize=(15, 15))
    n_cols = min(3, n_vars)
    n_rows = (n_vars + n_cols - 1) // n_cols

    for i, col in enumerate(df.columns[:-1]):
        plt.subplot(n_rows, n_cols, i+1)
        plt.plot(df['time'], df[col], label='Series', alpha=0.7)

        # Add trend line
        z = np.polyfit(df['time'], df[col], 1)
        p = np.poly1d(z)
        plt.plot(df['time'], p(df['time']), "r--", label='Trend')

        plt.title(f'{col} Components')
        plt.legend()
        plt.grid(True)

    plt.tight_layout()
    plt.savefig(f'{base_filename}_decomposition.png')
    plt.close()

    # Save causal structure description
    with open(f'{base_filename}_structure.txt', 'w') as f:
        f.write("Nonlinear Causal Structure:\n\n")
        f.write("Equations:\n")
        for eq in equations:
            f.write(f"{eq}\n")
        f.write("\nCausal Links:\n")
        for (source, lag, target, func), coef in true_links.items():
            f.write(f"X{source} --({func}, lag={lag})--> X{target}: {coef}\n")

def generate_all_combinations():
    """Generate datasets for all combinations"""
    sample_sizes = [500, 1000, 3000, 5000]
    n_vars_list = [4, 6, 8]
    max_lags = [2, 3, 4]
    trend_strengths = [0.01, 0.02]
    seasonal_strengths = [0.3, 0.5]

    for n in sample_sizes:
        for vars in n_vars_list:
            for lag in max_lags:
                for trend_str in trend_strengths:
                    for seas_str in seasonal_strengths:
                        print(f"\nGenerating dataset: n={n}, vars={vars}, lag={lag}, "
                              f"trend={trend_str}, seasonal={seas_str}")

                        generator = NonlinearTimeSeriesGenerator(
                            noise_scale=0.1,
                            trend_strength=trend_str,
                            seasonal_strength=seas_str,
                            seasonal_period=12,
                            random_state=42
                        )

                        df = generator.generate_multivariate_ts(
                            n_points=n,
                            n_vars=vars,
                            max_lag=lag
                        )

                        save_dataset_and_graph(df, vars, lag, n)
                        print("Dataset and visualizations saved successfully")

if __name__ == "__main__":
    print("Generating nonlinear time series with trends and seasonality...")

    # Generate datasets for specific combinations
    sample_sizes = [500, 1000, 3000, 5000]  # Using 1000 as example size
    n_vars_list = [4, 6, 8]
    max_lags = [2, 3, 4]

    for n in sample_sizes:
        for vars in n_vars_list:
            for lag in max_lags:
                print(f"\nGenerating dataset: n={n}, vars={vars}, lag={lag}")

                generator = NonlinearTimeSeriesGenerator(
                    noise_scale=0.1,
                    trend_strength=0.01,
                    seasonal_strength=0.5,
                    seasonal_period=12,
                    random_state=42
                )

                df = generator.generate_multivariate_ts(
                    n_points=n,
                    n_vars=vars,
                    max_lag=lag
                )

                save_dataset_and_graph(df, vars, lag, n)
                print(f"Dataset and visualizations saved successfully for {vars} variables with lag {lag}")

    print("\nAll datasets generated successfully!")

!zip -r /content/output_C1.zip /content/output_nonlinear
from google.colab import files
files.download('/content/output_C1.zip')